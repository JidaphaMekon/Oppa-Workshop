import torch
import torch.nn as nn
import torch.optim as optim
import numpy as np
import pandas as pd
import yfinance as yf
from torch.utils.data import DataLoader, TensorDataset
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
import matplotlib.pyplot as plt
import matplotlib.dates as mdates

# --- พารามิเตอร์ทั่วไป ---
start_date = '2013-01-01'
end_date = '2024-01-01'
window_size = 20
epochs = 100

# --- รายการสัญลักษณ์หุ้นที่ต้องการวิเคราะห์ ---
stock_symbols = [
    'AAME', 'AAPL', 'AVGO', 'NVDA', 'MSFT', 'META', 'AMD', 'GOOG', 'GOOGL'
]

# --- ฟังก์ชันและคลาส (กำหนดไว้นอก loop) ---
def create_sequences(data, window):
    X = []
    for i in range(len(data) - window):
        X.append(data[i:i + window])
    return np.array(X)

class PositionalEncoding(nn.Module):
    def __init__(self, d_model, dropout=0.1, max_len=5000):
        super().__init__()
        self.dropout = nn.Dropout(p=dropout)
        pe = torch.zeros(max_len, d_model)
        position = torch.arange(0, max_len, dtype=torch.float).unsqueeze(1)
        div_term = torch.exp(torch.arange(0, d_model, 2).float() * (-np.log(10000.0) / d_model))
        pe[:, 0::2] = torch.sin(position * div_term)
        pe[:, 1::2] = torch.cos(position * div_term)
        pe = pe.unsqueeze(0)  # shape: (1, max_len, d_model)
        self.register_buffer('pe', pe)

    def forward(self, x):
        # x shape: (batch_size, seq_len, d_model)
        x = x + self.pe[:, :x.size(1), :]
        return self.dropout(x)

class TransformerModel(nn.Module):
    def __init__(self, input_dim, model_dim=64, num_layers=2, num_heads=4, ffn_hid_dim=128, dropout=0.1):
        super().__init__()
        self.input_projection = nn.Linear(input_dim, model_dim)
        self.positional_encoding = PositionalEncoding(model_dim, dropout=dropout)
        self.transformer_encoder = nn.TransformerEncoder(
            nn.TransformerEncoderLayer(d_model=model_dim, nhead=num_heads, dim_feedforward=ffn_hid_dim, dropout=dropout, batch_first=True),
            num_layers=num_layers)
        self.fc_out = nn.Linear(model_dim, 1)

    def forward(self, x):
        x = self.input_projection(x)
        x = self.positional_encoding(x)
        x = self.transformer_encoder(x)
        return self.fc_out(x[:, -1, :]).squeeze(-1)

def train_model(model, train_loader, optimizer, criterion, epochs):
    model.train()
    for epoch in range(epochs):
        total_loss = 0
        for inputs, targets in train_loader:
            optimizer.zero_grad()
            outputs = model(inputs)
            loss = criterion(outputs, targets)
            loss.backward()
            optimizer.step()
            total_loss += loss.item()
        if (epoch + 1) % 10 == 0:
            print(f'  Epoch {epoch+1}, Loss: {total_loss / len(train_loader):.6f}')

def weighted_ensemble(transformer_model, linear_model, X_test_tensor, X_test_scaled, transformer_weight=0.70):
    transformer_model.eval()
    with torch.no_grad():
        transformer_preds = transformer_model(X_test_tensor).numpy()
    linear_preds = linear_model.predict(X_test_scaled.reshape(X_test_scaled.shape[0], -1))
    ensemble_preds = (transformer_preds * transformer_weight) + (linear_preds * (1 - transformer_weight))
    return ensemble_preds

# --- วนลูปผ่านแต่ละหุ้น ---
for stock_symbol in stock_symbols:
    print(f"\n{'='*50}")
    print(f"--- เริ่มประมวลผลสำหรับหุ้น: {stock_symbol} ---")
    print(f"{'='*50}")

    try:
        # 1. ดึงและเตรียมข้อมูล
        data = yf.download(stock_symbol, start=start_date, end=end_date, progress=False)
        if data.empty:
            print(f"ไม่พบข้อมูลสำหรับ {stock_symbol} ข้ามไปยังหุ้นถัดไป")
            continue

        data = data[['Open', 'High', 'Low', 'Close', 'Volume']].dropna()
        prices_multi = data.values
        dates = data.index

        if len(prices_multi) < window_size + 1:
            print(f"ข้อมูลของ {stock_symbol} มีไม่เพียงพอ ข้ามไปยังหุ้นถัดไป")
            continue

        # 2. สร้างลำดับข้อมูล (X) และกำหนดเป้าหมาย (y)
        X = create_sequences(prices_multi, window_size)
        y = prices_multi[window_size:, 3] # ใช้ราคาปิด (Close) เป็นเป้าหมาย

        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42, shuffle=False)
        _, X_test_dates, _, _ = train_test_split(dates[window_size:], y, test_size=0.2, random_state=42, shuffle=False)

        # 3. ทำการสเกลข้อมูล
        n_train_samples, n_timesteps, n_features = X_train.shape
        X_train_reshaped = X_train.reshape(-1, n_features)
        X_test_reshaped = X_test.reshape(-1, n_features)

        scaler = StandardScaler()
        X_train_scaled_reshaped = scaler.fit_transform(X_train_reshaped)
        X_test_scaled_reshaped = scaler.transform(X_test_reshaped)

        X_train_scaled = X_train_scaled_reshaped.reshape(n_train_samples, n_timesteps, n_features)
        X_test_scaled = X_test_scaled_reshaped.reshape(X_test.shape[0], n_timesteps, n_features)

        # 4. แปลงเป็น PyTorch Tensors และสร้าง DataLoader
        X_train_tensor = torch.tensor(X_train_scaled, dtype=torch.float32)
        y_train_tensor = torch.tensor(y_train, dtype=torch.float32)
        X_test_tensor = torch.tensor(X_test_scaled, dtype=torch.float32)
        y_test_tensor = torch.tensor(y_test, dtype=torch.float32)

        train_dataset = TensorDataset(X_train_tensor, y_train_tensor)
        train_loader = DataLoader(train_dataset, batch_size=64, shuffle=True)

        # 5. สร้างและฝึกโมเดล Transformer
        transformer_model = TransformerModel(input_dim=5, model_dim=64)
        optimizer = optim.Adam(transformer_model.parameters(), lr=0.001)
        criterion = nn.MSELoss()
        print("กำลังเทรนโมเดล Transformer...")
        train_model(transformer_model, train_loader, optimizer, criterion, epochs)

        # 6. ฝึกโมเดล Linear Regression
        print("\nกำลังเทรนโมเดล Linear Regression...")
        linear_model = LinearRegression().fit(X_train_scaled.reshape(n_train_samples, -1), y_train)

        # 7. ทำการพยากรณ์
        ensemble_preds = weighted_ensemble(transformer_model, linear_model, X_test_tensor, X_test_scaled)

        # 8. ประเมินประสิทธิภาพ
        ensemble_mse = mean_squared_error(y_test, ensemble_preds)
        ensemble_mae = mean_absolute_error(y_test, ensemble_preds)
        ensemble_rmse = np.sqrt(ensemble_mse)
        ensemble_r2 = r2_score(y_test, ensemble_preds)

        print("\n--- ผลการประเมินโมเดล Ensemble ---")
        print(f'Ensemble MSE: {ensemble_mse:.4f}')
        print(f"Ensemble MAE: {ensemble_mae:.4f}")
        print(f"Ensemble RMSE: {ensemble_rmse:.4f}")
        print(f"Ensemble R-squared: {ensemble_r2:.4f}")

        # 9. พล็อตผลลัพธ์
        plt.figure(figsize=(14, 7))
        plt.plot(X_test_dates, y_test, label='Actual Values', marker='.', linestyle='-', alpha=0.7)
        plt.plot(X_test_dates, ensemble_preds, label='Ensemble Predictions', marker='x', linestyle='--', alpha=0.7)
        plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m'))
        plt.gca().xaxis.set_major_locator(mdates.MonthLocator(interval=3))
        plt.gcf().autofmt_xdate()
        plt.xlabel('Date')
        plt.ylabel('Stock Price')
        plt.title(f'Actual Prices vs. Ensemble Predictions for {stock_symbol}')
        plt.legend()
        plt.grid(True)
        plt.show()
        print(f"--- เสร็จสิ้นการประมวลผลสำหรับ {stock_symbol} ---")

    except Exception as e:
        print(f"เกิดข้อผิดพลาดในการประมวลผลหุ้น {stock_symbol}: {e}")

print(f"\n{'='*50}")
print("--- การประมวลผลทุกหุ้นเสร็จสิ้น ---")
print(f"{'='*50}")
